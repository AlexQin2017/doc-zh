<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 351652 Maintainer: daijie Status: ready -->

 <chapter xml:id="language.exceptions" xmlns="http://docbook.org/ns/docbook">
  <title>异常处理</title>
   
  <sect1 xml:id="language.exceptions.extending">
   <title>扩展（extend） 异常处理类</title>
   <para>
    用户可以用自定义的异常处理类来扩展 PHP
    内置的异常处理类。以下的代码说明了在内置的异常处理类中，哪些属性和方法在子类中是可访问和可继承的。译者注：以下这段代码只为说明内置异常处理类的结构，它并不是一段有实际意义的可用代码。
   </para>
   <example>
    <title>内置的异常处理类</title>
    <programlisting role="php">
<![CDATA[
<?php
class Exception extends Throwable
{
    protected $message = 'Unknown exception';   // 异常信息
    private   $string;                          // __toString cache
    protected $code = 0;                        // 用户自定义异常代码
    protected $file;                            // 发生异常的文件名
    protected $line;                            // 发生异常的代码行号
    private   $trace;                           // backtrace
    private   $previous;                        // previous exception if nested exception

    public function __construct($message = null, $code = 0, Exception $previous = null);

    final private function __clone();           // Inhibits cloning of exceptions.

    final public  function getMessage();        // 返回异常信息
    final public  function getCode();           // 返回异常代码
    final public  function getFile();           // 返回发生异常的文件名
    final public  function getLine();           // 返回发生异常的代码行号
    final public  function getTrace();          // backtrace() 数组
    final public  function getPrevious();       // 之前的 exception
    final public  function getTraceAsString();  // 已格成化成字符串的 getTrace() 信息

    // Overrideable
    public function __toString();               // 可输出的字符串
}
?>
]]>
    </programlisting>
   </example>
   <para>
    如果使用自定义的类来扩展内置异常处理类，并且要重新定义<link
    linkend="language.oop5.decon">构造函数</link>的话，建议同时调用
    <link linkend="language.oop5.paamayim-nekudotayim">parent::__construct()</link>
    来确保所有的变量已赋值。当对象要输出字符串的时候，可以重载
    <link linkend="language.oop5.magic">__toString()</link> 并自定义输出的样式。
   </para>
   <note>
    <para>
     Exception 对象不能被复制。尝试对 Exception <link
     linkend="language.oop5.cloning">对象复制</link> 会导致一个 <constant>E_ERROR</constant> 级别的错误。
    </para>
   </note>
   <example>
    <title>扩展 PHP 内置的异常处理类</title>
    <programlisting role="php">
<![CDATA[
<?php
/**
 * 自定义一个异常处理类
 */
class MyException extends Exception
{
    // 重定义构造器使 message 变为必须被指定的属性
    public function __construct($message, $code = 0, Exception $previous = null) {
        // 自定义的代码

        // 确保所有变量都被正确赋值
        parent::__construct($message, $code, $previous);
    }

    // 自定义字符串输出的样式
    public function __toString() {
        return __CLASS__ . ": [{$this->code}]: {$this->message}\n";
    }

    public function customFunction() {
        echo "A custom function for this type of exception\n";
    }
}


/**
 * 创建一个用于测试异常处理机制的类
 */
class TestException
{
    public $var;

    const THROW_NONE    = 0;
    const THROW_CUSTOM  = 1;
    const THROW_DEFAULT = 2;

    function __construct($avalue = self::THROW_NONE) {

        switch ($avalue) {
            case self::THROW_CUSTOM:
                // 抛出自定义异常
                throw new MyException('1 is an invalid parameter', 5);
                break;

            case self::THROW_DEFAULT:
                // 抛出默认的异常
                throw new Exception('2 is not allowed as a parameter', 6);
                break;

            default: 
                // 没有异常的情况下，创建一个对象
                $this->var = $avalue;
                break;
        }
    }
}


// 例子 1
try {
    $o = new TestException(TestException::THROW_CUSTOM);
} catch (MyException $e) {      // 捕获异常
    echo "Caught my exception\n", $e;
    $e->customFunction();
} catch (Exception $e) {        // 被忽略
    echo "Caught Default Exception\n", $e;
}

// Continue execution
var_dump($o); // Null
echo "\n\n";


// 例子 2
try {
    $o = new TestException(TestException::THROW_DEFAULT);
} catch (MyException $e) {      //  不能匹配异常的种类，被忽略
    echo "Caught my exception\n", $e;
    $e->customFunction();
} catch (Exception $e) {        // 捕获异常
    echo "Caught Default Exception\n", $e;
}

// 执行后续代码
var_dump($o); // Null
echo "\n\n";


// 例子 3
try {
    $o = new TestException(TestException::THROW_CUSTOM);
} catch (Exception $e) {        // 捕获异常
    echo "Default Exception caught\n", $e;
}

// 执行后续代码
var_dump($o); // Null
echo "\n\n";


// 例子 4
try {
    $o = new TestException();
} catch (Exception $e) {        // 没有异常，被忽略
    echo "Default Exception caught\n", $e;
}

// 执行后续代码
var_dump($o); // TestException
echo "\n\n";
?>
]]>
    </programlisting>
   </example>
  </sect1>

  <simplesect xml:id="language.exceptions.introduction">
   <para>
    PHP 有一个和其他语言相似的异常模型。
    在 PHP 里可以 &throw; 并 &catch; 异常。
    为了捕获潜在的异常，可以将代码包含在 &try; 块里。
    每个 &try; 都必须有一个相应的
    &catch; 或 &finally; 代码块。
   </para>
   <para>
    如果抛出异常的函数范围内没有 &catch; 块，异常会沿调用栈“向上冒泡”，
    直到找到匹配的 &catch; 块。
    沿途会执行所有遇到的 &finally; 块。
    在没有设置全局异常处理程序（exception handler）时，
    如果调用栈向上都没有遇到匹配的 &catch;，程序会抛出 fatal 错误并终止执行。
   </para>
   <para>
   抛出的对象必须是 <classname>Exception</classname> 自身或
   <classname>Exception</classname>的子类。
    抛出其他对象会导致 PHP 报 Fatal 错误。
   </para>
   <para>
   PHP 8.0.0 起，&throw; 关键词现在开始是一个表达式，可用于任何表达式的场景。
   在此之前，它是一个语句，必须独占一行。
   </para>

  </simplesect>

  <simplesect xml:id="language.exceptions.catch">
   <title><literal>catch</literal></title>
   <para>
    A &catch; block defines how to respond to a thrown exception.  A &catch;
    block defines one or more types of exception or error it can handle, and
    optionally a variable to which to assign the exception. (The variable was
    required prior to PHP 8.0.0.)  The first &catch; block a thrown exception
    or error encounters that matches the type of the thrown object will handle
    the object.
   </para>
   <para>
    Multiple &catch; blocks can be used to catch different classes of
    exceptions. Normal execution (when no exception is thrown within the &try;
    block) will continue after that last &catch; block defined in sequence.
    Exceptions can be &throw;n (or re-thrown) within a &catch; block. If not,
    execution will continue after the &catch; block that was triggered.
   </para>
   <para>
    When an exception is thrown, code following the statement will not be
    executed, and PHP will attempt to find the first matching &catch; block.
    If an exception is not caught, a PHP Fatal Error will be issued with an
    "<literal>Uncaught Exception ...</literal>" message, unless a handler has
    been defined with <function>set_exception_handler</function>.
   </para>
   <para>
    As of PHP 7.1.0, a &catch; block may specify multiple exceptions
    using the pipe (<literal>|</literal>) character. This is useful for when
    different exceptions from different class hierarchies are handled the
    same.
   </para>
   <para>
    As of PHP 8.0.0, the variable name for a caught exception is optional.
    If not specified, the &catch; block will still execute but will not
    have access to the thrown object.
   </para>
  </simplesect>

  <simplesect xml:id="language.exceptions.finally">
   <title><literal>finally</literal></title>
   <para>
    A &finally; block may also be specified after or
    instead of &catch; blocks. Code within the &finally; block will always be
    executed after the &try; and &catch; blocks, regardless of whether an
    exception has been thrown, and before normal execution resumes.
   </para>
   <para>
    One notable interaction is between the &finally; block and a &return; statement.
    If a &return; statement is encountered inside either the &try; or the &catch; blocks,
    the &finally; block will still be executed. Moreover, the &return; statement is
    evaluated when encountered, but the result will be returned after the &finally; block
    is executed. Additionally, if the &finally; block also contains a &return; statement,
    the value from the &finally; block is returned.
   </para>
  </simplesect>

 <simplesect xml:id="language.exceptions.exception-handler">
  <title><literal>Global exception handler</literal></title>
  <para>
   If an exception is allowed to bubble up to the global scope, it may be caught
   by a global exception handler if set.  The <function>set_exception_handler</function>
   function can set a function that will be called in place of a &catch; block if no
   other block is invoked.  The effect is essentially the same as if the entire program
   were wrapped in a &try;-&catch; block with that function as the &catch;.
  </para>
 </simplesect>

 <simplesect xml:id="language.exceptions.notes">
   &reftitle.notes;

   <note>
    <para>
     Internal PHP functions mainly use
     <link linkend="ini.error-reporting">Error reporting</link>, only modern
     <link linkend="language.oop5">Object oriented</link>
     extensions use exceptions. However, errors can be easily translated to
     exceptions with <link linkend="class.errorexception">ErrorException</link>.
     This technique only works with non-fatal errors, however.
    </para>
    <example>
     <title>Converting error reporting to exceptions</title>
     <programlisting role="php">
<![CDATA[
<?php
function exceptions_error_handler($severity, $message, $filename, $lineno) {
    throw new ErrorException($message, 0, $severity, $filename, $lineno);
}

set_error_handler('exceptions_error_handler');
?>
]]>
     </programlisting>
    </example>
   </note>
   <tip>
    <para>
     The <link linkend="intro.spl">Standard PHP Library (SPL)</link> provides
     a good number of <link linkend="spl.exceptions">built-in
     exceptions</link>.
    </para>
   </tip>
  </simplesect>

  <simplesect xml:id="language.exceptions.examples">
   &reftitle.examples;

   <example>
    <title>Throwing an Exception</title>
    <programlisting role="php">
<![CDATA[
<?php
function inverse($x) {
    if (!$x) {
        throw new Exception('Division by zero.');
    }
    return 1/$x;
}

try {
    echo inverse(5) . "\n";
    echo inverse(0) . "\n";
} catch (Exception $e) {
    echo 'Caught exception: ',  $e->getMessage(), "\n";
}

// Continue execution
echo "Hello World\n";
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
0.2
Caught exception: Division by zero.
Hello World
]]>
    </screen>
   </example>
   <example>
    <title>Exception handling with a &finally; block</title>
    <programlisting role="php">
<![CDATA[
<?php
function inverse($x) {
    if (!$x) {
        throw new Exception('Division by zero.');
    }
    return 1/$x;
}

try {
    echo inverse(5) . "\n";
} catch (Exception $e) {
    echo 'Caught exception: ',  $e->getMessage(), "\n";
} finally {
    echo "First finally.\n";
}

try {
    echo inverse(0) . "\n";
} catch (Exception $e) {
    echo 'Caught exception: ',  $e->getMessage(), "\n";
} finally {
    echo "Second finally.\n";
}

// Continue execution
echo "Hello World\n";
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
0.2
First finally.
Caught exception: Division by zero.
Second finally.
Hello World
]]>
    </screen>
   </example>
   <example>
    <title>Interaction between the &finally; block and &return;</title>
    <programlisting role="php">
<![CDATA[
<?php

function test() {
    try {
        throw new Exception('foo');
    } catch (Exception $e) {
        return 'catch';
    } finally {
        return 'finally';
    }
}

echo test();
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
finally
]]>
    </screen>
   </example>
   <example>
    <title>Nested Exception</title>
    <programlisting role="php">
<![CDATA[
<?php

class MyException extends Exception { }

class Test {
    public function testing() {
        try {
            try {
                throw new MyException('foo!');
            } catch (MyException $e) {
                // rethrow it
                throw $e;
            }
        } catch (Exception $e) {
            var_dump($e->getMessage());
        }
    }
}

$foo = new Test;
$foo->testing();

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
string(4) "foo!"
]]>
    </screen>
   </example>
   <example>
    <title>Multi catch exception handling</title>
    <programlisting role="php">
<![CDATA[
<?php

class MyException extends Exception { }

class MyOtherException extends Exception { }

class Test {
    public function testing() {
        try {
            throw new MyException();
        } catch (MyException | MyOtherException $e) {
            var_dump(get_class($e));
        }
    }
}

$foo = new Test;
$foo->testing();

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
string(11) "MyException"
]]>
    </screen>
   </example>
   <example>
    <title>Omitting the caught variable</title>
    <para>Only permitted in PHP 8.0.0 and later.</para>
    <programlisting role="php">
<![CDATA[
<?php

class SpecificException extends Exception {}

function test() {
    throw new SpecificException('Oopsie');
}

try {
    test();
} catch (SpecificException) {
    print "A SpecificException was thrown, but we don't care about the details.";
}
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>Throw as an expression</title>
    <para>Only permitted in PHP 8.0.0 and later.</para>
    <programlisting role="php">
<![CDATA[
<?php

class SpecificException extends Exception {}

function test() {
    do_something_risky() or throw new Exception('It did not work');
}

try {
    test();
} catch (Exception $e) {
    print $e->getMessage();
}
?>
]]>
    </programlisting>
   </example>
  </simplesect>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
